diff --git a/content/renderer/browser_plugin/browser_plugin.cc b/content/renderer/browser_plugin/browser_plugin.cc
index 06762fb..e89b1f0 100644
--- a/content/renderer/browser_plugin/browser_plugin.cc
+++ b/content/renderer/browser_plugin/browser_plugin.cc
@@ -448,15 +448,11 @@ blink::WebInputEventResult BrowserPlugin::handleInputEvent(

   DCHECK(!blink::WebInputEvent::isTouchEventType(event.type()));

-  // With direct event routing turned on, BrowserPlugin should almost never
-  // see wheel events any more. The two exceptions are (1) scroll bubbling, and
-  // (2) synthetic mouse wheels generated by touchpad GesturePinch events on
-  // Mac, which always go to the mainframe and thus may hit BrowserPlugin if
-  // it's in a top-level embedder. In both cases we should indicate the event
-  // as not handled (for GesturePinch on Mac, indicating the event has been
-  // handled leads to touchpad pinch not working).
-  if (event.type() == blink::WebInputEvent::MouseWheel)
-    return blink::WebInputEventResult::NotHandled;
+  if (event.type() == blink::WebInputEvent::MouseWheel) {
+    auto wheel_event = static_cast<const blink::WebMouseWheelEvent&>(event);
+    if (wheel_event.resendingPluginId == browser_plugin_instance_id_)
+      return blink::WebInputEventResult::NotHandled;
+  }

   if (blink::WebInputEvent::isGestureEventType(event.type())) {
     auto gesture_event = static_cast<const blink::WebGestureEvent&>(event);
